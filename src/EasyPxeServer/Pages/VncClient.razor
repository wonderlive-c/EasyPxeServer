@page "/vnc-client"
@layout EmptyLayout
@using EasyPxeServer.Services
@inject VncService         VncService
@inject IJSRuntime         JSRuntime
@inject ILogger<VncClient> logger

@* 使用空布局，不显示导航栏 *@

<PageTitle>VNC 客户端 - @ConnectionName</PageTitle>

<!-- Always force latest IE rendering engine (even in intranet) &
                Chrome Frame. Remove this if you use the .htaccess -->
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>

@* 隐藏默认的Blazor布局，使页面适合在弹出窗口中显示 *@
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #212529;
        color: white;
    }
    
    .vnc-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        width: 100vw;
    }
    
    .vnc-header {
        background-color: #343a40;
        padding: 10px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #495057;
    }
    
    .vnc-title {
        margin: 0;
        font-size: 18px;
        font-weight: 500;
    }
    
    .vnc-controls {
        display: flex;
        gap: 10px;
    }
    
    .vnc-controls button {
        padding: 6px 12px;
        background-color: #495057;
        border: none;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }
    
    .vnc-controls button:hover {
        background-color: #6c757d;
    }
    
    .vnc-display {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #212529;
        overflow: hidden;
    }
    
    #vnc-display-container {
        position: relative;
    }
    
    #vnc-status {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.7);
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none;
    }
    
    /* 进度指示器 */
    .progress {
        height: 4px;
        background-color: #495057;
        overflow: hidden;
    }
    
    .progress-bar {
        height: 100%;
        background-color: #007bff;
        width: 0%;
        transition: width 0.3s;
    }
</style>
<!-- actual script modules -->
<script type="module" crossorigin="anonymous">
    // RFB holds the API to connect and communicate with a VNC server
    import RFB from '/flexem/novnc/core/rfb.js';

    let rfb;
    let desktopName;
    let ref;

    // When this function is called we have
    // successfully connected to a server
    window.connectedToServer = function (e) {
        ref.invokeMethodAsync("OnConnect", e.detail.name);
    }

    // This function is called when we are disconnected
    window.disconnectedFromServer = function (e) {

        if (e.detail.clean) {
            ref.invokeMethodAsync("OnDisconnect");
        } else {
            ref.invokeMethodAsync("OnError", "Something went wrong, connection is closed");
        }
    }

    // When this function is called, the server requires
    // credentials to authenticate
    window.credentialsAreRequired = function (e) {
        const password = prompt("Password Required:");
        rfb.sendCredentials({ password: password });
    }

    // When this function is called we have received
    // a desktop name from the server
    window.updateDesktopName = function (e) {
        desktopName = e.detail.name;
        window.title = desktopName + " - VNC 客户端";
    }

    // Since most operating systems will catch Ctrl+Alt+Del
    // before they get a chance to be intercepted by the browser,
    // we provide a way to emulate this key sequence.
    window.sendCtrlAltDel = function () {
        rfb.sendCtrlAltDel();
        return false;
    }

    // Show a status text in the top bar
    function status(text) {
        ref.invokeMethodAsync("ShowStatus", text);
    }

    // This function extracts the value of one variable from the
    // query string. If the variable isn't defined in the URL
    // it returns the default value instead.
    function readQueryVariable(name, defaultValue) {
        // A URL with a query parameter can look like this:
        // https://www.example.com?myqueryparam=myvalue
        //
        // Note that we use location.href instead of location.search
        // because Firefox < 53 has a bug w.r.t location.search
        const re = new RegExp('.*[?&]' + name + '=([^&#]*)'),
              match = document.location.href.match(re);

        if (match) {
            // We have to decode the URL since want the cleartext value
            return decodeURIComponent(match[1]);
        }

        return defaultValue;
    }
    
    window.beginConnect = function (targetId, url, dotNetRef, password){
        
        ref=dotNetRef;
        // Creating a new RFB object will start a new connection
        rfb = new RFB(document.getElementById(targetId), url,
                      { credentials: { password: password } });

        // Add listeners to important events from the RFB module
        rfb.addEventListener("connect",  connectedToServer);
        rfb.addEventListener("disconnect", disconnectedFromServer);
        rfb.addEventListener("credentialsrequired", credentialsAreRequired);
        rfb.addEventListener("desktopname", updateDesktopName);

        // Set parameters that can be changed on an active connection
        rfb.viewOnly = false;
        rfb.scaleViewport = true;
    }
    window.disconnectNoVNC = function () {
        if (rfb) {
            rfb.disconnect();
        }
    }

    window.toggleFullscreenNoVNC = function () {
        if (rfb) {
            rfb.toggleFullScreen();
        }
    }
    

</script>

<div class="vnc-container">
    <!-- 进度条 -->
    <div class="progress">
        <div class="progress-bar" style="width: @ProgressPercent%"></div>
    </div>

    <!-- 标题栏 -->
    <div class="vnc-header">
        <h2 class="vnc-title">VNC 客户端 - @ConnectionName (@Host:@Port)</h2>
        <div class="vnc-controls">
            <button @onclick="SendCtrlAltDel" title="发送 Ctrl+Alt+Del">
                <i class="fas fa-keyboard mr-1"></i>Ctrl+Alt+Del
            </button>
            <button @onclick="ToggleFullscreen" title="切换全屏">
                <i class="fas fa-expand mr-1"></i>全屏
            </button>
            <button @onclick="Disconnect" title="断开连接" class="text-danger">
                <i class="fas fa-times mr-1"></i>断开
            </button>
        </div>
    </div>

    <!-- VNC 显示区域 -->
    <div class="vnc-display">
        <div id="vnc-display-container" class="novnc-display-container">
            @if (!IsConnected)
            {
                <div style="text-align: center; padding: 40px;">
                    <div class="spinner-border text-primary" style="width: 4rem; height: 4rem; margin-bottom: 20px;"></div>
                    <p>正在连接到 @Host:@Port...</p>
                    <p>请稍候，正在建立VNC会话...</p>
                </div>
            }
            <div id="vnc-display-@ConnectionId" class="vnc-display-element" style="width: @Width; height: @Height;"></div>
            <div id="vnc-status">
                @StatusMessage
            </div>
        </div>
    </div>
</div>

@code {

    // 从查询参数获取连接信息
    [Parameter]
    [SupplyParameterFromQuery]
    public string ConnectionId { get; set; }

    [Parameter]
    [SupplyParameterFromQuery]
    public string Host { get; set; }

    [Parameter]
    [SupplyParameterFromQuery]
    public int Port { get; set; }

    [Parameter]
    [SupplyParameterFromQuery]
    public int Width { get; set; }

    [Parameter]
    [SupplyParameterFromQuery]
    public int Height { get; set; }

    private string ConnectionName { get; set; }

    // 连接状态
    private bool                             IsConnected     { get; set; } = false;
    private string                           StatusMessage   { get; set; } = "准备连接...";
    private int                              ProgressPercent { get; set; } = 0;
    private DotNetObjectReference<VncClient> _dotNetRef;

    // 实现IDisposable接口
    private bool _disposed = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            logger.LogInformation("VNC客户端初始化");
            // 初始化VNC连接
            await InitializeVncConnection();
        }
    }


    private async Task InitializeVncConnection()
    {
        try
        {
            // 检查必要参数
            if (string.IsNullOrEmpty(ConnectionId)
             || string.IsNullOrEmpty(Host)
             || Port <= 0)
            {
                StatusMessage = "无效的连接参数";
                return;
            }

            // 更新状态
            StatusMessage   = "正在初始化VNC连接...";
            ProgressPercent = 20;
            StateHasChanged();
            logger.LogInformation("初始化VNC连接");
            // 等待一小段时间以显示进度
            await Task.Delay(200);

            // 创建DotNet引用
            _dotNetRef = DotNetObjectReference.Create(this);

            // 初始化连接
            logger.LogInformation("开始连接到VNC服务器");
            var connection = await VncService.GetConnection(ConnectionId);

            if (connection == null)
            {
                logger.LogWarning("未找到连接配置");
                StatusMessage   = "未找到连接配置";
                ProgressPercent = 0;
                StateHasChanged();
                return;
            }

            logger.LogInformation("连接配置: " + connection);
            ConnectionName = connection.ConnectionName;
            await JSRuntime.InvokeVoidAsync("beginConnect", "vnc-display-" + ConnectionId, connection.WebSocketUrl, _dotNetRef, connection.Password);

            // 更新进度
            ProgressPercent = 60;
            StatusMessage   = "正在建立连接...";
            StateHasChanged();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "初始化VNC连接时出错");
            StatusMessage   = $"连接失败: {ex.Message}";
            ProgressPercent = 0;
            StateHasChanged();
            Console.WriteLine("VNC初始化错误: " + ex.Message);
        }
    }

    private async Task SendCtrlAltDel()
    {
        try
        {
            logger.LogInformation("发送 Ctrl+Alt+Del");
            await JSRuntime.InvokeVoidAsync("sendCtrlAltDel");
            await ShowStatus("已发送 Ctrl+Alt+Del", 2000);
        }
        catch (Exception ex) { await ShowStatus($"发送失败: {ex.Message}", 3000); }
    }

    private async Task ToggleFullscreen()
    {
        logger.LogInformation("切换全屏");
        try { await JSRuntime.InvokeVoidAsync("toggleFullscreenNoVNC", ConnectionId); }
        catch (Exception ex) { await ShowStatus($"切换全屏失败: {ex.Message}", 3000); }
    }

    private async Task Disconnect()
    {
        try
        {
            logger.LogInformation("断开连接");
            StatusMessage = "正在断开连接...";
            StateHasChanged();

            await JSRuntime.InvokeVoidAsync("disconnectNoVNC", ConnectionId);
            await VncService.RemoveConnection(ConnectionId);

            // 等待一小段时间以显示状态
            await Task.Delay(500);

            // 关闭窗口
            await JSRuntime.InvokeVoidAsync("close");
        }
        catch (Exception ex) { await ShowStatus($"断开连接失败: {ex.Message}", 3000); }
    }

    [JSInvokable]
    public async Task ShowStatus(string message, int duration = 3000)
    {
        logger.LogInformation("显示状态: " + message);
        StatusMessage = message;
        StateHasChanged();

        await Task.Delay(duration);

        // 如果状态没有被其他操作更新，则恢复默认状态
        if (StatusMessage == message)
        {
            StatusMessage = IsConnected ? "已连接" : "未连接";
            StateHasChanged();
        }
    }

    // 处理连接状态变化的回调方法，供JavaScript调用
    [JSInvokable]
    public void OnConnect()
    {
        logger.LogInformation("连接成功");
        IsConnected     = true;
        StatusMessage   = "已连接";
        ProgressPercent = 100;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnDisconnect()
    {
        logger.LogInformation("连接断开");
        IsConnected     = false;
        StatusMessage   = "已断开连接";
        ProgressPercent = 0;
        StateHasChanged();

        // 延迟后关闭窗口
        Task.Run(async () =>
        {
            await Task.Delay(2000);
            await JSRuntime.InvokeVoidAsync("close");
        });
    }

    [JSInvokable]
    public void OnError(string error)
    {
        logger.LogError(error);
        StatusMessage   = $"错误: {error}";
        ProgressPercent = 0;
        StateHasChanged();
    }

    // 确保组件实现IDisposable接口
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // 清理托管资源
                if (_dotNetRef != null)
                {
                    _dotNetRef.Dispose();
                    _dotNetRef = null;
                }

                // 断开VNC连接（异步操作，但在Dispose中我们只能进行同步调用）
                try
                {
                    // 这里不使用await，因为Dispose是同步方法
                    if (!string.IsNullOrEmpty(ConnectionId))
                    {
                        _ = JSRuntime.InvokeVoidAsync("disconnectNoVNC", ConnectionId);
                        _ = VncService.RemoveConnection(ConnectionId);
                    }
                }
                catch (Exception ex) { Console.WriteLine("清理VNC连接时出错: " + ex.Message); }
            }

            // 清理非托管资源（如果有的话）
            _disposed = true;
        }
    }

}