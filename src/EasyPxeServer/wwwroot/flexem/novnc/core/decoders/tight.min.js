/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/@flexem/novnc@1.1.6/core/decoders/tight.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import*as Log from"../util/logging.js";import Inflator from"../inflator.js";export default class TightDecoder{constructor(){this._ctl=null,this._filter=null,this._numColors=0,this._palette=new Uint8Array(1024),this._len=0,this._zlibs=[];for(let t=0;t<4;t++)this._zlibs[t]=new Inflator}decodeRect(t,e,i,r,l,s,h){if(null===this._ctl){if(l.rQwait("TIGHT compression-control",1))return!1;this._ctl=l.rQshift8();for(let t=0;t<4;t++)this._ctl>>t&1&&(this._zlibs[t].reset(),Log.Info("Reset zlib stream "+t));this._ctl=this._ctl>>4}let n;if(8===this._ctl)n=this._fillRect(t,e,i,r,l,s,h);else if(9===this._ctl)n=this._jpegRect(t,e,i,r,l,s,h);else if(10===this._ctl)n=this._pngRect(t,e,i,r,l,s,h);else{if(128&this._ctl)throw new Error("Illegal tight compression received (ctl: "+this._ctl+")");n=this._basicRect(this._ctl,t,e,i,r,l,s,h)}return n&&(this._ctl=null),n}_fillRect(t,e,i,r,l,s,h){if(l.rQwait("TIGHT",3))return!1;const n=l.rQi,f=l.rQ;return s.fillRect(t,e,i,r,[f[n+2],f[n+1],f[n]],!1),l.rQskipBytes(3),!0}_jpegRect(t,e,i,r,l,s,h){let n=this._readData(l);return null!==n&&(s.imageRect(t,e,i,r,"image/jpeg",n),!0)}_pngRect(t,e,i,r,l,s,h){throw new Error("PNG received in standard Tight rect")}_basicRect(t,e,i,r,l,s,h,n){if(null===this._filter)if(4&t){if(s.rQwait("TIGHT",1))return!1;this._filter=s.rQshift8()}else this._filter=0;let f,_=3&t;switch(this._filter){case 0:f=this._copyFilter(_,e,i,r,l,s,h,n);break;case 1:f=this._paletteFilter(_,e,i,r,l,s,h,n);break;case 2:f=this._gradientFilter(_,e,i,r,l,s,h,n);break;default:throw new Error("Illegal tight filter received (ctl: "+this._filter+")")}return f&&(this._filter=null),f}_copyFilter(t,e,i,r,l,s,h,n){const f=r*l*3;let _;if(f<12){if(s.rQwait("TIGHT",f))return!1;_=s.rQshiftBytes(f)}else{if(_=this._readData(s),null===_)return!1;this._zlibs[t].setInput(_),_=this._zlibs[t].inflate(f),this._zlibs[t].setInput(null)}return h.blitRgbImage(e,i,r,l,_,0,!1),!0}_paletteFilter(t,e,i,r,l,s,h,n){if(0===this._numColors){if(s.rQwait("TIGHT palette",1))return!1;const t=s.rQpeek8()+1,e=3*t;if(s.rQwait("TIGHT palette",1+e))return!1;this._numColors=t,s.rQskipBytes(1),s.rQshiftTo(this._palette,e)}const f=this._numColors<=2?1:8,_=Math.floor((r*f+7)/8)*l;let a;if(_<12){if(s.rQwait("TIGHT",_))return!1;a=s.rQshiftBytes(_)}else{if(a=this._readData(s),null===a)return!1;this._zlibs[t].setInput(a),a=this._zlibs[t].inflate(_),this._zlibs[t].setInput(null)}return 2==this._numColors?this._monoRect(e,i,r,l,a,this._palette,h):this._paletteRect(e,i,r,l,a,this._palette,h),this._numColors=0,!0}_monoRect(t,e,i,r,l,s,h){const n=this._getScratchBuffer(i*r*4),f=Math.floor((i+7)/8),_=Math.floor(i/8);for(let t=0;t<r;t++){let e,r,h;for(h=0;h<_;h++)for(let _=7;_>=0;_--)e=4*(t*i+8*h+7-_),r=3*(l[t*f+h]>>_&1),n[e]=s[r],n[e+1]=s[r+1],n[e+2]=s[r+2],n[e+3]=255;for(let _=7;_>=8-i%8;_--)e=4*(t*i+8*h+7-_),r=3*(l[t*f+h]>>_&1),n[e]=s[r],n[e+1]=s[r+1],n[e+2]=s[r+2],n[e+3]=255}h.blitRgbxImage(t,e,i,r,n,0,!1)}_paletteRect(t,e,i,r,l,s,h){const n=this._getScratchBuffer(i*r*4),f=i*r*4;for(let t=0,e=0;t<f;t+=4,e++){const i=3*l[e];n[t]=s[i],n[t+1]=s[i+1],n[t+2]=s[i+2],n[t+3]=255}h.blitRgbxImage(t,e,i,r,n,0,!1)}_gradientFilter(t,e,i,r,l,s,h,n){throw new Error("Gradient filter not implemented")}_readData(t){if(0===this._len){if(t.rQwait("TIGHT",3))return null;let e;e=t.rQshift8(),this._len=127&e,128&e&&(e=t.rQshift8(),this._len|=(127&e)<<7,128&e&&(e=t.rQshift8(),this._len|=e<<14))}if(t.rQwait("TIGHT",this._len))return null;let e=t.rQshiftBytes(this._len);return this._len=0,e}_getScratchBuffer(t){return(!this._scratchBuffer||this._scratchBuffer.length<t)&&(this._scratchBuffer=new Uint8Array(t)),this._scratchBuffer}}
//# sourceMappingURL=/sm/50cdc842011dc4be358a022306a3197246dbef2d908cd7e033de8fceb7607e26.map